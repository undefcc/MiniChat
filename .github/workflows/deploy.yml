name: Build and Deploy MiniChat to Aliyun ECS

on:
  push:
    branches: [ master ]
    paths:
      - 'apps/**'
      - 'libs/**'
      - 'pnpm-lock.yaml'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      service:
        description: 'é€‰æ‹©è¦éƒ¨ç½²çš„æœåŠ¡ (web/signaling/gateway/all)'
        required: true
        default: 'all'
        type: choice
        options:
          - all
          - web
          - signaling
          - gateway

env:
  REGISTRY: crpi-zpvonb2nha7j0qgy.cn-shenzhen.personal.cr.aliyuncs.com
  IMAGE_NAMESPACE: cc4ever
  WEB_APP_NAME: minichat-web
  SIGNALING_APP_NAME: minichat-signaling
  GATEWAY_APP_NAME: minichat-gateway

jobs:
  # æ£€æµ‹å“ªäº›æœåŠ¡å‘ç”Ÿäº†å˜åŒ–
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      web: ${{ steps.filter.outputs.web }}
      signaling: ${{ steps.filter.outputs.signaling }}
      gateway: ${{ steps.filter.outputs.gateway }}
      manual_service: ${{ github.event.inputs.service }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Check changed files
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            web:
              - 'apps/web/**'
              - 'pnpm-lock.yaml'
            signaling:
              - 'apps/signaling/**'
              - 'libs/common/**'
              - 'pnpm-lock.yaml'
            gateway:
              - 'apps/gateway/**'
              - 'libs/common/**'
              - 'pnpm-lock.yaml'

  build-and-push:
    runs-on: ubuntu-latest
    needs: detect-changes
    strategy:
      matrix:
        service: [web, signaling, gateway]
    steps:
      # æ£€æŸ¥æ˜¯å¦éœ€è¦æž„å»ºæ­¤æœåŠ¡
      - name: Check if build needed
        id: should_build
        run: |
          # æ‰‹åŠ¨è§¦å‘æ—¶
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            MANUAL_SERVICE="${{ needs.detect-changes.outputs.manual_service }}"
            if [ "$MANUAL_SERVICE" = "all" ] || [ "$MANUAL_SERVICE" = "${{ matrix.service }}" ]; then
              echo "build=true" >> $GITHUB_OUTPUT
            else
              echo "build=false" >> $GITHUB_OUTPUT
            fi
          # è‡ªåŠ¨è§¦å‘æ—¶ï¼Œæ£€æŸ¥æ–‡ä»¶å˜åŒ–
          else
            if [ "${{ matrix.service }}" = "web" ] && [ "${{ needs.detect-changes.outputs.web }}" = "true" ]; then
              echo "build=true" >> $GITHUB_OUTPUT
            elif [ "${{ matrix.service }}" = "signaling" ] && [ "${{ needs.detect-changes.outputs.signaling }}" = "true" ]; then
              echo "build=true" >> $GITHUB_OUTPUT
            elif [ "${{ matrix.service }}" = "gateway" ] && [ "${{ needs.detect-changes.outputs.gateway }}" = "true" ]; then
              echo "build=true" >> $GITHUB_OUTPUT
            else
              echo "build=false" >> $GITHUB_OUTPUT
            fi
          fi

      # æ­¥éª¤1: æ£€å‡ºä»£ç 
      - name: Checkout code
        if: steps.should_build.outputs.build == 'true'
        uses: actions/checkout@v3

      # æ­¥éª¤2: è®¾ç½® pnpm
      - name: Setup pnpm
        if: steps.should_build.outputs.build == 'true'
        uses: pnpm/action-setup@v2
        with:
          version: 8

      # ç¡®ä¿ pnpm store ç›®å½•å­˜åœ¨ï¼Œé¿å… cache åŠ¨ä½œæç¤ºè·¯å¾„ä¸å­˜åœ¨
      - name: Ensure pnpm store dir exists
        if: steps.should_build.outputs.build == 'true'
        run: |
          mkdir -p "$(pnpm store path 2>/dev/null || echo ~/.pnpm-store/v3)"

      # æ­¥éª¤3: è®¾ç½® Node.js çŽ¯å¢ƒ
      - name: Setup Node.js
        if: steps.should_build.outputs.build == 'true'
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'pnpm'

      # æ­¥éª¤4: ç™»å½•é˜¿é‡Œäº‘ Docker Registry
      - name: Login to Aliyun Container Registry
        if: steps.should_build.outputs.build == 'true'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.ALIYUN_DOCKER_USERNAME }}
          password: ${{ secrets.ALIYUN_DOCKER_PASSWORD }}

      # æ­¥éª¤5: è®¾ç½®é•œåƒåç§°
      - name: Set image name
        if: steps.should_build.outputs.build == 'true'
        id: image
        run: |
          if [ "${{ matrix.service }}" = "web" ]; then
            echo "name=${{ env.WEB_APP_NAME }}" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.service }}" = "signaling" ]; then
            echo "name=${{ env.SIGNALING_APP_NAME }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ env.GATEWAY_APP_NAME }}" >> $GITHUB_OUTPUT
          fi

      # æ­¥éª¤6: æž„å»ºå¹¶æŽ¨é€ Docker é•œåƒ
      - name: Build and push ${{ matrix.service }} image
        if: steps.should_build.outputs.build == 'true'
        run: |
          IMAGE_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ steps.image.outputs.name }}:${GITHUB_SHA:0:8}
          IMAGE_LATEST=${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ steps.image.outputs.name }}:latest
          
          echo "ðŸ”¨ æž„å»º ${{ matrix.service }} æœåŠ¡é•œåƒ..."
          docker build \
            -t $IMAGE_TAG \
            -t $IMAGE_LATEST \
            -f apps/${{ matrix.service }}/Dockerfile \
            --build-arg SERVICE_NAME=${{ matrix.service }} \
            .
          
          echo "ðŸ“¤ æŽ¨é€é•œåƒåˆ°é˜¿é‡Œäº‘..."
          docker push $IMAGE_TAG
          docker push $IMAGE_LATEST
          
          echo "âœ… ${{ matrix.service }} é•œåƒæž„å»ºå®Œæˆ: $IMAGE_LATEST"

  # deploy-to-ecs:
  #   runs-on: ubuntu-latest
  #   needs: [detect-changes, build-and-push]
  #   steps:
  #     - name: Deploy to Aliyun ECS via SSH
  #       uses: appleboy/ssh-action@v0.1.9
  #       with:
  #         host: ${{ secrets.ECS_HOST }}
  #         username: ${{ secrets.ECS_USERNAME }}
  #         key: ${{ secrets.ECS_SSH_PRIVATE_KEY }}
  #         script: |
  #           # ç™»å½•é˜¿é‡Œäº‘å®¹å™¨é•œåƒæœåŠ¡
  #           docker login --username=${{ secrets.ALIYUN_DOCKER_USERNAME }} --password=${{ secrets.ALIYUN_DOCKER_PASSWORD }} ${{ env.REGISTRY }}
            
  #           # åˆ‡æ¢åˆ°é¡¹ç›®ç›®å½•
  #           cd /opt/minichat || mkdir -p /opt/minichat && cd /opt/minichat
            
  #           # åˆ›å»º docker-compose.ymlï¼ˆå¦‚æžœä¸å­˜åœ¨ï¼‰
  #           cat > docker-compose.yml << 'EOF'
  #           version: '3.8'
  #           services:
  #             web:
  #               image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.WEB_APP_NAME }}:latest
  #               container_name: minichat-web
  #               restart: unless-stopped
  #               ports:
  #                 - "3100:3100"
  #               environment:
  #                 - NODE_ENV=production
  #                 - NEXT_PUBLIC_SOCKET_URL=http://your-domain.com:3101
  #               depends_on:
  #                 - signaling
              
  #             signaling:
  #               image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.SIGNALING_APP_NAME }}:latest
  #               container_name: minichat-signaling
  #               restart: unless-stopped
  #               ports:
  #                 - "3101:3101"
  #               environment:
  #                 - NODE_ENV=production
  #                 - PORT=3101
  #                 - CORS_ORIGIN=http://your-domain.com:3100
              
  #             gateway:
  #               image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAMESPACE }}/${{ env.GATEWAY_APP_NAME }}:latest
  #               container_name: minichat-gateway
  #               restart: unless-stopped
  #               ports:
  #                 - "4000:4000"
  #               environment:
  #                 - NODE_ENV=production
  #                 - PORT=4000
  #                 - JWT_SECRET=${{ secrets.JWT_SECRET }}
  #                 - DATABASE_URL=${{ secrets.DATABASE_URL }}
  #           EOF
            
  #           # åˆ¤æ–­éœ€è¦æ›´æ–°å“ªäº›æœåŠ¡
  #           SERVICES_TO_UPDATE=""
            
  #           if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
  #             # æ‰‹åŠ¨è§¦å‘
  #             MANUAL_SERVICE="${{ needs.detect-changes.outputs.manual_service }}"
  #             if [ "$MANUAL_SERVICE" = "all" ]; then
  #               SERVICES_TO_UPDATE="web signaling gateway"
  #             else
  #               SERVICES_TO_UPDATE="$MANUAL_SERVICE"
  #             fi
  #           else
  #             # è‡ªåŠ¨è§¦å‘ï¼Œæ ¹æ®æ–‡ä»¶å˜åŒ–æ›´æ–°
  #             [ "${{ needs.detect-changes.outputs.web }}" = "true" ] && SERVICES_TO_UPDATE="$SERVICES_TO_UPDATE web"
  #             [ "${{ needs.detect-changes.outputs.signaling }}" = "true" ] && SERVICES_TO_UPDATE="$SERVICES_TO_UPDATE signaling"
  #             [ "${{ needs.detect-changes.outputs.gateway }}" = "true" ] && SERVICES_TO_UPDATE="$SERVICES_TO_UPDATE gateway"
  #           fi
            
  #           echo "ðŸš€ å‡†å¤‡æ›´æ–°æœåŠ¡: $SERVICES_TO_UPDATE"
            
  #           # æ‹‰å–å¹¶é‡å¯å¯¹åº”çš„æœåŠ¡
  #           for service in $SERVICES_TO_UPDATE; do
  #             echo "ðŸ“¦ æ‹‰å– $service æœ€æ–°é•œåƒ..."
  #             docker-compose pull $service
              
  #             echo "ðŸ”„ é‡å¯ $service æœåŠ¡..."
  #             docker-compose up -d --no-deps $service
              
  #             echo "âœ… $service æœåŠ¡å·²æ›´æ–°"
  #           done
            
  #           # æ¸…ç†æœªä½¿ç”¨çš„é•œåƒ
  #           docker image prune -f
            
  #           echo "ðŸŽ‰ éƒ¨ç½²å®Œæˆï¼"